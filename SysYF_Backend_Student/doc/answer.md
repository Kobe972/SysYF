## 实现思路

### 任务1：寄存器分配算法

#### 形式化问题

现在有若干个Interval，每个Interval是一系列左闭右开的区间（range_list），有若干个寄存器，现在希望把这些区间尽可能地放入这些寄存器中，满足放入每个寄存器的Interval两两不相交。

#### 略微修改的传统线性扫描算法

主要的数据结构：`    std::set<Interval*,cmp_interval>reg_for_intervals[12];`表示当前的寄存器所分配的intervals集合。

主要的算法仍然是按照当前Interval对应range_list最左端点开始扫描：

1. 定义pos表示当前扫描到的Interval对应range_list的最左端点。

2. 每扫描到一个pos，计算reg_for_intervals里面每个Interval的权重。权重定义为从pos开始往后这个Interval的range_list覆盖的活跃区域长度。当一个range_list从pos开始的活跃区域长度为0的时候，说明这个range_list不可能和后续的任何一个Interval产生冲突，就可以直接把寄存器分配给这个Interval，然后把这个Interval从reg_for_intervals里面移除。

3. 从第一个可用的寄存器开始往下按顺序看看当前Interval（current）可不可以插入这个reg_for_interval(是否和这个集合里面的所有Interval不相交)，如果可以，直接插入，转步骤5。

4. 发现不可以直接插入的时候，计算current的权重，如果current的权重比所有的reg_for_intervals集合里面的权重都大，那么直接溢出current，否则弹出权重最大的那个Interval，跳转步骤3，

5. 扫描结束，将放在reg_for_interval中剩下的Interval分配。

### 任务2：Phi指令的数据移动

### 形式化问题

一堆源数据地址移动到对应的各不相同的目的数据地址。不能破坏已有的寄存器的值，单次移动需要一个临时寄存器。

### 转化问题

我们可以把所有用到的数据地址看成一系列节点，把每一个源到目的地的点对看成一条边。那么就形成了一张图。由于目的地各不相同，所以每个点的入度只有1。

每个点入度只有1的图形成了一张**外向基环树森林**。也就是，每个连通块，要么是一颗有根树，要么是中心为环，从中心环向外伸展的带一个环的树。

### 算法

对于树的情况，实际上只需要按照从叶子节点往上移动数据顺序就可以保证数据顺利迁移。

对于环的情况，先把环上的一个点的值存在一个临时寄存器里面，剩下的节点顺环沿逆边方向数据迁移最后把存下的那个点的值放入对应的位置就可以顺利迁移。

单次移动所用的寄存器用lr(为保存原来的值，开头push，结尾pop)。

为了处理环的情况，牺牲一个寄存器分配位置用来处理数据迁移的情况。（也可以把值放压栈然后弹栈，只是选择闲置了一个寄存器的方法）


